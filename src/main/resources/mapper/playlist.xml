<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="mapper.PlaylistMapper">

	<resultMap type="Playlist" id="playlistMap">
		<id column="pl_code" property="plCode" />
		<result column="pl_title" property="plTitle" />
		<result column="pl_img" property="plImg" />
		<result column="pl_date" property="plDate" />
		<result column="pl_public_yn" property="plPublicYn" />
		<result column="pl_code_count" property="likeCount"/>
		<association property="user" javaType="User">
			<id column="user_email" property="userEmail" />
			<result column="user_password" property="userPassword" />
			<result column="user_nickname" property="userNickname" />
			<result column="user_img" property="userImg" />
			<result column="user_date" property="userDate" />
			<result column="user_ent_yn" property="userEntYn" />
			<result column="user_spotify_yn" property="userSpotifyYn" />
			<result column="user_gender" property="userGender" />
			<result column="user_birth" property="userBirth" />
			<result column="user_manager" property="userManager" />
			<result column="user_enroll_date" property="userEnrollDate" />
			<result column="user_phone" property="userPhone" />
			<result column="age_group" property="ageGroup" />
		</association>
	</resultMap>
	
	<resultMap type="PlayListTag" id="listTagMap">
		<id column="pl_tag_code" property="plTagCode" />
		<association property="tag" javaType="Tag">
			<id column="tag_code" property="tagCode" />
			<result column="tag_name" property="tagName" />
		</association>
	</resultMap>
	
	<resultMap type="PlaylistLike" id="likeMap">
		<id column="like_code" property="likeCode"/>
	</resultMap>

	<!-- 전체플리 조회 -->
	<select id="allPlaylist" resultMap="playlistMap" parameterType="SearchDTO">
		SELECT * FROM playlist
		JOIN user USING (user_email)
		WHERE pl_public_yn = 'Y'
		<!-- 타이틀로 검색 쿼리 -->
		<if test="select == 'title' and search != ''">
			AND lower(pl_title) LIKE CONCAT('%', #{search}, '%')
		</if>
		<if test="codes != null">
			AND pl_code IN
			<foreach collection="codes" item="code" open="(" close=")"
				separator=",">
				#{code}
			</foreach>
		</if>
		ORDER BY pl_code DESC
		LIMIT #{offset}, #{limit}
	</select>
	
	<!-- 전체플리 조회  limit 5 고정 -->
	<select id="rankPlaylist" resultMap="playlistMap"
		parameterType="SearchDTO">
		SELECT pl_code, pl_title, pl_img, u.user_email, u.user_nickname, u.user_img
		FROM playlist p
		JOIN user u ON (u.user_email = p.user_email)
	    	LEFT JOIN playlist_like USING (pl_code)
		WHERE pl_public_yn = 'Y'
		<!-- 타이틀로 검색 쿼리 -->
		<if test="select == 'title' and search != ''">
			AND lower(pl_title) LIKE CONCAT('%', #{search}, '%')
		</if>
		<if test="codes != null">
			AND pl_code IN
			<foreach collection="codes" item="code" open="(" close=")"
				separator=",">
				#{code}
			</foreach>
		</if>
		GROUP BY pl_code
		ORDER BY COUNT(like_code) DESC
		LIMIT 5
	</select>
	
	<!-- 플레이리스트 태그테이블에서 태그 검색 쿼리(중복 제거) -->
	<select id="searchTag" resultType="Integer" parameterType="String">
		SELECT distinct pl_code 
		FROM playlist_tag
			JOIN tag USING (tag_code)
		WHERE lower(tag_name) LIKE CONCAT('%', #{search}, '%')
	</select>
	
	<!-- 플레이리스트 플레이리스트코드마다 태그 가져오는 쿼리 -->
	<select id="searchTagPlayList" resultMap="listTagMap" parameterType="Integer">
		SELECT * 
		FROM playlist_tag
			JOIN tag USING (tag_code)
		WHERE pl_code = #{code}
	</select>
	
	<!-- 무한스크롤 --> 
	<!-- 
	<select id="limitAllPlaylist" resultMap="playlistMap"
		parameterType="Paging">
		SELECT * FROM playlist
		JOIN user USING (user_email)
		WHERE pl_public_yn = 'Y'
		 타이틀로 검색 쿼리
		<if test="search != null">
			AND pl_title LIKE CONCAT('%', #{search}, '%')
		</if>
		 태그로 검색 쿼리 
		<if test="codes != null">
			AND pl_code IN
			<foreach collection="codes" item="code" open="(" close=")"
				separator=",">
				#{code}
			</foreach>
		</if>
	</select>
 -->

	<!-- 플레이리스트 생성 --> <!-- 이미지 추가! -->
	<insert id="createPlaylist" parameterType="CreatePlaylistDTO" useGeneratedKeys="true" keyProperty="plCode" keyColumn="pl_code">
		INSERT INTO
		playlist(pl_title, user_email, pl_img, pl_public_yn)
		VALUES (#{plTitle}, #{userEmail}, #{plImg}, #{plPublicYn})
	</insert>
	
	
	<!-- 플레이리스트 이미지 업데이트  
	<update id="updatePlaylist" parameterType="Playlist">
		UPDATE playlist
		SET pl_img = #{plImg}
		WHERE pl_code = #{pl_code}
	</update>
	-->
	
	<!-- 플레이리스트 제목과 이미지 동시에 업데이트 -->
	<update id="updatePlaylist" parameterType="UpdatePlaylistDTO">
		UPDATE playlist
		SET pl_title = #{plTitle}, pl_img = #{plImg}
		WHERE pl_code = #{plCode}
	</update>

	<!-- user 탈퇴 시 playlist 정보 넘기기 -->
	<update id="movePlaylist" parameterType="String">
		UPDATE playlist
		SET
		user_email = 'playlist@vibemaster.com'
		WHERE user_email = #{userEmail}
	</update>

	<!-- 회원 본인의 플레이리스트 조회 -->
	<select id="myPlaylist" resultMap="playlistMap" parameterType="SearchDTO">
		SELECT * FROM playlist
		JOIN user USING (user_email)
		WHERE user_email = #{userEmail}
		ORDER BY pl_code DESC
		LIMIT #{offset}, #{limit};
	</select>

	<!-- 플레이리스트 코드로 플레이리스트 정보 조회 -->
	<select id="selectPlaylistByPlCode" resultMap="playlistMap" parameterType="Integer">
		SELECT * FROM playlist
		WHERE pl_code = #{plCode}
	</select>

	<!-- 플레이리스트 관련 음악 삭제 -->
	<delete id="deletePlaylistMusic" parameterType="Integer">
		DELETE FROM playlist_music WHERE pl_code = #{plCode}
	</delete>

	<!-- 플레이리스트 삭제 -->
	<delete id="deletePlaylist" parameterType="Integer">
		DELETE FROM playlist WHERE pl_code = #{plCode}
	</delete>

    <!-- 플레이리스트 태그 삭제 -->
	<delete id="deletePlaylistTags" parameterType="Integer">
	    DELETE FROM playlist_tag WHERE pl_code = #{plCode}
	</delete>
	
	<!-- 플레이리스트 제목 수정 -->
    <update id="updatePlaylistTitle" parameterType="Playlist">
        UPDATE playlist
        SET pl_title = #{plTitle}
        WHERE pl_code = #{plCode}
    </update>
    
    <!-- 랭킹 : 좋아요순 -->
    <select id="likerankingPlaylist" resultMap="playlistMap" parameterType="SearchDTO">
    	SELECT pl_code, pl_title, pl_img, pl_date, u.user_email, u.user_nickname, u.user_img, count(pl_code)
    	FROM playlist p
	    	JOIN user u ON (u.user_email = p.user_email)
	    	LEFT JOIN playlist_like USING (pl_code)
    	WHERE pl_public_yn = 'Y'
    	GROUP BY pl_code
    	ORDER BY COUNT(like_code) DESC
    	LIMIT #{offset}, #{limit}
    </select>
    
    <!-- 랭킹 : 좋아요 TOP3 -->
    <select id="rankTop" resultMap="playlistMap">
    	SELECT pl_code, pl_title, pl_img, pl_date, u.user_email, u.user_nickname, count(pl_code)
    	FROM playlist p
	    	JOIN user u ON (u.user_email = p.user_email)
	    	LEFT JOIN playlist_like USING (pl_code)
    	WHERE pl_public_yn = 'Y'
    	GROUP BY pl_code
    	ORDER BY COUNT(like_code) DESC
    	LIMIT 3
    </select>
    
    <!-- 특정 회원의 최고 인기 플레이리스트 조회-->
    <select id="likeRankByUserEmail" resultMap="playlistMap" parameterType="String">
    	SELECT pl_code, pl_title, pl_img, pl_date, u.user_email, u.user_nickname, u.user_img
    	FROM playlist p
	    	JOIN user u ON (u.user_email = p.user_email)
	    	LEFT JOIN playlist_like USING (pl_code)
    	WHERE u.user_email = #{user_email}
    	GROUP BY pl_code
    	ORDER BY COUNT(like_code) DESC
    	LIMIT 1
    </select>

	<!-- 플레이리스트 코드로 태그 이름 조회 -->
	<select id="findTagsByPlaylistCode" resultType="String" parameterType="int">
	    SELECT tag_name 
	    FROM playlist
		    JOIN playlist_tag USING (pl_code)
		    JOIN tag USING (tag_code)
	    WHERE pl_code = #{plCode}
	</select>
	
	<!-- 플레이리스트 랜덤 조회 -->
	<select id="randomPlaylist" resultMap="playlistMap" parameterType="String">
		SELECT *
		FROM playlist
		JOIN user USING (user_email)
		WHERE pl_public_yn = 'Y'
			AND user_email != #{userEmail}
		ORDER BY RAND()
	</select>

	<!-- 검색 태그별 랭킹 조회 -->
	<select id="searchTagRanking" parameterType="String"
		resultMap="playlistMap">
		SELECT p.pl_code, p.pl_title, p.pl_img, p.pl_date,
		p.pl_public_yn, u.user_nickname, COUNT(*) AS pl_code_count
		FROM
		playlist p
		JOIN user u ON p.user_email = u.user_email
		JOIN playlist_like pl ON p.pl_code = pl.pl_code
		JOIN playlist_tag pt ON p.pl_code = pt.pl_code
		JOIN tag t ON pt.tag_code = t.tag_code
		WHERE t.tag_name LIKE CONCAT('%',
		#{tagName}, '%')
		GROUP BY p.pl_code, u.user_nickname
		ORDER BY
		pl_code_count DESC;
	</select>

	<!-- 한달 동안의 플레이리스트 랭킹 조회 -->
	<select id="playListRankingOnMonth" resultMap="playlistMap">
		SELECT p.pl_code,
		p.pl_title, p.pl_img, p.pl_date,
		p.pl_public_yn, u.user_nickname,
		COUNT(*) AS pl_code_count
		FROM playlist p
			JOIN user u ON p.user_email = u.user_email
			JOIN playlist_like pl ON p.pl_code = pl.pl_code
			JOIN playlist_tag pt ON p.pl_code = pt.pl_code
			JOIN tag t ON pt.tag_code = t.tag_code
		WHERE p.pl_date BETWEEN
			DATE_SUB(CURRENT_DATE(), INTERVAL 1 MONTH) AND CURRENT_DATE()
			AND pl_public_yn = 'Y'
		GROUP BY p.pl_code, u.user_nickname
		ORDER BY pl_code_count DESC;
	</select>
	
	<!-- 연령대별 좋아요 랭킹 -->
	<select id="playListRankingOnAgeGroup" parameterType="SearchDTO"
		resultMap="playlistMap">
		SELECT
		CASE
			WHEN FLOOR(DATEDIFF(CURDATE(), u.user_birth) / 365.25) BETWEEN 10 AND 19
				THEN '10'
			WHEN FLOOR(DATEDIFF(CURDATE(), u.user_birth) / 365.25) BETWEEN 20 AND 29
				THEN '20'
			WHEN FLOOR(DATEDIFF(CURDATE(), u.user_birth) / 365.25) BETWEEN 30 AND 39
				THEN '30'
			WHEN FLOOR(DATEDIFF(CURDATE(), u.user_birth) / 365.25) BETWEEN 40 AND 49
				THEN '40'
			WHEN FLOOR(DATEDIFF(CURDATE(), u.user_birth) / 365.25) BETWEEN 50 AND 59
				THEN '50'
			ELSE 'etc'
				END AS age_group, 
			p.pl_code, p.pl_title, p.pl_img, p.pl_date, p.pl_public_yn, u.user_nickname, u.user_email, u.user_img, COUNT(*) AS pl_code_count
		FROM playlist p
			JOIN user u ON p.user_email = u.user_email
			JOIN playlist_like pl ON p.pl_code = pl.pl_code
		WHERE pl_public_yn = 'Y'
		GROUP BY age_group, p.pl_code, u.user_nickname
		HAVING age_group = #{ageGroup}
		ORDER BY age_group, pl_code_count DESC
		LIMIT #{offset}, #{limit}
	</select>

	<!-- 성별 별 좋아요 랭킹 -->
	<select id="playListRankingOnGender" parameterType="SearchDTO"
		resultMap="playlistMap">
		SELECT p.pl_code, p.pl_title, p.pl_img, p.pl_date, p.pl_public_yn, 
			u.user_nickname, u.user_email, u.user_img, COUNT(like_code) AS pl_code_count
		FROM user u
			JOIN playlist p ON (u.user_email = p.user_email)
			JOIN playlist_like USING (pl_code)
		WHERE user_gender = #{userGender}
			AND pl_public_yn = 'Y'
		GROUP BY pl_code
		ORDER BY pl_code_count desc
		LIMIT #{offset}, #{limit}
	</select>
</mapper>